{
  "tools_use": false,
  "tools_system_prompt": "Nutze das Tool `get_metadata' um die Daten abzurufen und gib nur das Tool-Call JSON zurück.\r\nDu darfst die Metadaten nicht schätzen.\r\nWenn du das Tool get_metadata für eine ITEM-VX Abfrage verwendest, nutze immer folgendes Format:\r\n{\r\n  \"name\": \"get_metadata\",\r\n  \"arguments\": {\r\n    \"item-vx\": \"<ITEM-VX-XXXXXX>\"\r\n  }\r\n}\r\n",
  "tools_json": "[\r\n  {\r\n    \"type\": \"function\",\r\n    \"function\": {\r\n      \"name\": \"get_metadata\",\r\n      \"description\": \"Gibt die Metadaten für eine ITEM-VX zurück.\",\r\n      \"parameters\": {\r\n        \"type\": \"object\",\r\n        \"properties\": {\r\n          \"item-vx\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"Die Item-VX im Format ITEM-VX-0000000\"\r\n          }\r\n        },\r\n        \"required\": [\"item-vx\"]\r\n      }\r\n    }\r\n  }\r\n]",
  "tools_python_code": "import os\r\nimport sys\r\nimport json\r\nimport requests\r\nimport warnings\r\nimport urllib3\r\nimport xml.etree.ElementTree as ET\r\n\r\n# === Proxy & SSL-Warnungen deaktivieren ===\r\nfor var in [\"HTTP_PROXY\", \"HTTPS_PROXY\", \"http_proxy\", \"https_proxy\"]:\r\n    os.environ.pop(var, None)\r\nwarnings.simplefilter(\"ignore\", urllib3.exceptions.InsecureRequestWarning)\r\n\r\n# === Konfiguration ===\r\nOAUTH_URL = \"https://muvie.ad.ndr-net.de/auth/realms/vidispine/connect/token\"\r\nAPI_BASE_URL = \"https://muvie.ad.ndr-net.de/API\"\r\n\r\nCLIENT_ID = \"externalClient\"\r\nCLIENT_SECRET = \"90731259-08A6-4b0d-8F5F-7FC848C77602\"\r\n\r\n\r\n# === Hilfsfunktionen ===\r\ndef _xml_element_to_dict(elem):\r\n    \"\"\"\r\n    Konvertiert ein xml.etree.ElementTree.Element rekursiv in ein Python-Dict.\r\n    Attribute werden mit '@attrname' gespeichert, Text mit '#text'.\r\n    Gleichnamige Kinder werden als Liste gruppiert.\r\n    \"\"\"\r\n    node = {}\r\n    # Attribute\r\n    for k, v in elem.attrib.items():\r\n        node[f\"@{k}\"] = v\r\n\r\n    # Kinder\r\n    children = list(elem)\r\n    if children:\r\n        child_map = {}\r\n        for child in children:\r\n            child_name = child.tag\r\n            child_dict = _xml_element_to_dict(child)\r\n            if child_name in child_map:\r\n                # bereits vorhanden -> Liste\r\n                if not isinstance(child_map[child_name], list):\r\n                    child_map[child_name] = [child_map[child_name]]\r\n                child_map[child_name].append(child_dict)\r\n            else:\r\n                child_map[child_name] = child_dict\r\n        node.update(child_map)\r\n    # Text (falls vorhanden und nicht nur whitespace)\r\n    text = (elem.text or \"\").strip()\r\n    if text:\r\n        node[\"#text\"] = text\r\n\r\n    return node\r\n\r\n\r\ndef parse_response_content(response):\r\n    \"\"\"\r\n    Versucht, die Antwort in der Reihenfolge zu parsen:\r\n      1. JSON (Content-Type oder heuristisch)\r\n      2. XML (Content-Type oder heuristisch)\r\n      3. Sonst: roher Text (string)\r\n    Gibt Python-Objekt (dict/list/str) zurück.\r\n    \"\"\"\r\n    text = response.text or \"\"\r\n    ct = (response.headers.get(\"Content-Type\") or \"\").lower()\r\n\r\n    # 1) JSON, wenn Content-Type JSON oder Text beginnt mit { oder [\r\n    json_like = \"application/json\" in ct or text.lstrip().startswith((\"{\", \"[\"))\r\n    if json_like:\r\n        try:\r\n            return response.json()\r\n        except Exception:\r\n            # Falls fehlerhaftes JSON, weiter versuchen\r\n            pass\r\n\r\n    # 2) XML, wenn Content-Type xml oder Text beginnt mit <?xml or <\r\n    xml_like = (\"xml\" in ct) or text.lstrip().startswith(\"<?xml\") or text.lstrip().startswith(\"<\")\r\n    if xml_like:\r\n        try:\r\n            root = ET.fromstring(text)\r\n            return {root.tag: _xml_element_to_dict(root)}\r\n        except Exception:\r\n            # Wenn XML-Parsing fehlschlägt, weiter unten Rohtext zurückgeben\r\n            pass\r\n\r\n    # 3) Fallback: wenn leerer Body\r\n    if not text.strip():\r\n        return None\r\n\r\n    # 4) Letzter Versuch: JSON parse ohne rely auf header\r\n    try:\r\n        return json.loads(text)\r\n    except Exception:\r\n        pass\r\n\r\n    # 5) Sonst roher Text\r\n    return text\r\n\r\n\r\n# === OAuth & API Funktionen ===\r\ndef get_access_token():\r\n    \"\"\"Holt ein OAuth2-Access-Token mit Client-Credentials-Flow.\"\"\"\r\n    data = {\r\n        \"grant_type\": \"client_credentials\",\r\n        \"client_id\": CLIENT_ID,\r\n        \"client_secret\": CLIENT_SECRET\r\n    }\r\n\r\n    response = requests.post(OAUTH_URL, data=data, verify=False)\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Fehler beim Abrufen des Tokens: {response.status_code} - {response.text}\")\r\n\r\n    # Erwartet normalerweise JSON; falls nicht, parse robust\r\n    parsed = parse_response_content(response)\r\n    if isinstance(parsed, dict):\r\n        return parsed.get(\"access_token\")\r\n    else:\r\n        raise Exception(f\"Token-Response nicht im erwarteten JSON-Format: {type(parsed).__name__} | Inhalt: {response.text}\")\r\n\r\n\r\ndef get_metadata(item_vx, token):\r\n    \"\"\"Ruft die Metadaten für ein bestimmtes Item ab und parst JSON/XML/Text.\"\"\"\r\n    url = f\"{API_BASE_URL}/item/{item_vx}/metadata\"\r\n    headers = {\r\n        \"Authorization\": f\"Bearer {token}\",\r\n        \"Accept\": \"application/json\"       # <<< WICHTIG\r\n    }\r\n\r\n    response = requests.get(url, headers=headers, verify=False)\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Fehler beim Abrufen der Metadaten: {response.status_code} - {response.text}\")\r\n\r\n    parsed = parse_response_content(response)\r\n    return parsed\r\n\r\n# === Hauptprogramm ===\r\nif len(sys.argv) != 2:\r\n    print(\"Bitte ein JSON-Argument übergeben.\")\r\n    sys.exit(1)\r\n\r\ntry:\r\n    json_input = json.loads(sys.argv[1])\r\n    name = json_input.get(\"name\")\r\n    item_vx = json_input.get(\"arguments\", {}).get(\"item-vx\")\r\n\r\n    if name != \"get_metadata\":\r\n        print(\"Ungültiger Funktionsname. Verwende 'get_metadata'.\")\r\n        sys.exit(1)\r\n\r\n    if not item_vx:\r\n        print(\"Fehler: 'item-vx' fehlt im Argument.\")\r\n        sys.exit(1)\r\n\r\n    token = get_access_token()\r\n    result = get_metadata(item_vx, token)\r\n\r\n    # Wenn None (leerer Body), gebe klaren Hinweis\r\n    if result is None:\r\n        print(json.dumps({\"message\": \"Leere Antwort vom Server (kein Inhalt).\"}, indent=2, ensure_ascii=False))\r\n    else:\r\n        # Falls Ergebnis einfacher String (Text), gib es als Objekt zurück\r\n        if isinstance(result, (str,)):\r\n            print(json.dumps({\"text\": result}, indent=2, ensure_ascii=False))\r\n        else:\r\n            print(json.dumps(result, indent=2, ensure_ascii=False))\r\n\r\nexcept Exception as e:\r\n    print(f\"Fehler: {e}\")\r\n    sys.exit(1)",
  "tools_extract_prompt": "Verwende folgende JSON um die Frage zu beantworten:\\n```json\\n{TOOLS_RESPONSE}'''"
}